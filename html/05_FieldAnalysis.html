<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Análisis de superficies</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/Serif.css" id="theme">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">

		<link rel="stylesheet" href="dist/style.css">



		<style>
				  
			.primera #marca-agua{
				display:none;
				}

			.primera #lecture{
				display:none;
				}

			#clock {
				font-size: 20px;
				color: #51483D;
				width: 120px;
				margin: 0px;
				text-align: center;
				border: 2px solid black;
				border-radius: 20px;
				}


			.reveal section p {
				font-size: 0.7em;
				  }

			.reveal section li {
				font-size: 0.6em;
				  }

			.reveal .slide-number {
				right: 150px;
				 bottom: 3px}

			.reveal h3 {
				text-align: left;
				  }

		</style>

	</head>
	<body>

		<script>
			setInterval(showTime, 1000);
			function showTime() {
				let time = new Date();
				let hour = time.getHours();
				let min = time.getMinutes();
				let sec = time.getSeconds();
				am_pm = "am";
	
				if (hour > 12) {
					hour -= 12;
					am_pm = "pm";
				}
				if (hour == 0) {
					hr = 12;
					am_pm = "am";
				}
	
				hour = hour < 10 ? "0" + hour : hour;
				min = min < 10 ? "0" + min : min;
				sec = sec < 10 ? "0" + sec : sec;
	
				let currentTime = hour + ":"
					+ min + ":" + sec + am_pm;
	
				document.getElementById("clock")
					.innerHTML = currentTime;
			}
	
			showTime();
		</script>

		<div class="reveal">
			<div class="slides">
			
				<div id="marca-agua"><img style="border:none;box-shadow:none;width:60px;position:absolute;top:0%;right:0%;"src="images/un.png"/><p id="date"></p></div>
				<!--<div id="lecture" style="font-size:20px;position:absolute;top:100%;right:32%;">Machine Learning (Introducción)</div>-->
				<div id="clock" style="font-size:20px;position:absolute;top:98%;right:0%;">0:00:00</div>
				<section data-background-color= "#ffffff"; data-state="primera">
				  <h1>ANÁLISIS GEOESPACIAL</h1>
				  <h2>Análisis de modelos continuos</h2>
				  <p>
				  <h4><a href="https://edieraristizabal.github.io/">Prof. Edier Aristizábal</a></h4>
				  </p>
					<img src="images/unal2.png" alt="unal.jpg" width="500"/>
					<p id="demo" style="position:absolute;top:100%;right:40%;"></p>
					<script>
					var d = new Date();
					var months = ["Jan.","Feb.","Mar.","Apr.","May.","Jun.","Jul.","Aug.","Sept.","Oct.","Nov.","Dec."];
					document.getElementById("demo").innerHTML = months[d.getMonth()] + " " +d.getDate()+" / "+d.getFullYear();
					</script>
				</section>

				<section>
					<section>
						<h2>Geostatistics</h2>
						<p>The type of spatial statistical analysis dealing with
							continuous field variables is named “geostatistics”</p>

							<p> Geostatistics focus on the description of the spatial variation in a set of observed values and on their prediction at unsampled
								locations</p>

					</section>


				</section>

				<section>
					<h1>Spatial interpolation</h1>

					<section>
						<p>techniques used with points that represent samples of a continuous field are interpolation methods</p>
						<p>Here, our point data represents sampled observations of an entity that can be measured anywhere within our study area</p>
						<p>There are many interpolation tools available, but these tools can usually be grouped into two categories: <strong>deterministic</strong> and  interpolation methods</p>
					</section>

					<section>
						<h3>Proximity interpolation</h3>
						<p> It was introduced by Alfred H. Thiessen more than a century ago. The goal is simple: Assign to all 
							unsampled locations the value of the closest sampled location. This generates a tessellated surface 
							whereby lines that split the midpoint between each sampled location are connected thus enclosing an area.
							 Each area ends up enclosing a sample point whose value it inherits.</p>
							 <img src="https://mgimond.github.io/Spatial/14-Spatial-Interpolation_files/figure-html/f14-proximity-1.png" width="1000">
					</section>

					<section>
						<h3>Proximity interpolation</h3>
						<img src="images/blocky.png" width="600">
					</section>

					<section>
						<h3>Inverse Distance Weighted (IDW)</h3>
						<p> The IDW technique computes an average value for unsampled locations using values from nearby weighted 
							locations. The weights are proportional to the proximity of the sampled points to the unsampled location 
							and can be specified by the IDW power coefficient. </p>
							$\hat{Z_j} = \frac{\sum_i{Z_i/d^n_{ij}}}{\sum_i{1/d^n_{ij}}}$
						<p>So a large  
							n
							  results in nearby points wielding a much greater influence on the unsampled location than a point further away resulting in an interpolated output looking like a Thiessen interpolation. On the other hand, a very small value of  
							n
							  will give all points within the search radius equal weight such that all unsampled locations will represent nothing more than the mean values of all sampled points within the search radius.</p>
					</section>

					<section>
						<h3>Kriging</h3>
						<p>Several forms of kriging interpolators exist: ordinary, universal and simple just to name a few. This section will focus on ordinary kriging (OK) interpolation. This form of kriging usually involves four steps:</p>
						<ul>
							<li>Removing any spatial trend in the data</li>
							<li>Computing the experimental variogram, $γ$ , which is a measure of spatial autocorrelation.</li>
							<li>Defining an experimental variogram model that best characterizes the spatial autocorrelation in the data.</li>
							<li>Interpolating the surface using the experimental variogram.</li>
							<li>Adding the kriged interpolated surface to the trend interpolated surface to produce the final output.</li>
						</ul>
					</section>

					<section>
						<p> We are interested in how these attribute values vary as the distance 
							between location point pairs increases. We can compute the difference, $γ$, in values by squaring their 
							differences then dividing by 2.</p>
							<img src="https://mgimond.github.io/Spatial/14-Spatial-Interpolation_files/figure-html/f13-two-sites-1.png" width="1000">
							$\gamma = \frac{(Z_2 - Z_1)^2}{2} = \frac{(-1.2 - (1.6))^2}{2} = 3.92$
					</section>

					<section>
						<h3>Experimental variogram</h3>
						<img src="https://mgimond.github.io/Spatial/14-Spatial-Interpolation_files/figure-html/f14-variogram-1.png" width="1000">
					</section>

					<section>
						<h3>Experimental variogram</h3>
						<img src="https://mgimond.github.io/Spatial/14-Spatial-Interpolation_files/figure-html/f14-sample-variogram-1.png" width="1000">
					</section>

					<section>
						<h3>Experimental semivariogram</h3>
						<img src="images/semivario.png" width="620">
					</section>

					<section>
						<h3>Variogram models</h3>
						<img src="https://mgimond.github.io/Spatial/14-Spatial-Interpolation_files/figure-html/f14-variogram-models-1.png" width="800">
					</section>

					<section>
						<h3>Variogram models</h3>
						<img src="https://gisgeography.com/wp-content/uploads/2016/11/kriging-models-1.png" width="800">
					</section>

					<section>
						<h3>Parameters in a variogram model</h3>
						<img src="https://mgimond.github.io/Spatial/14-Spatial-Interpolation_files/figure-html/f14-model-explained-1.png" width="1000">
					</section>

					<section>
						<h3>Spherical model fit</h3>
						<img src="https://mgimond.github.io/Spatial/14-Spatial-Interpolation_files/figure-html/f14-spherical-model-1.png" width="1000">
					</section>
				</section>
			
			
				
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script src="plugin/menu/menu.js"></script>
		<script src="plugin/math/math.js"></script>

		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				controls: true,
				progress: true,
				center: true,
				slideNumber: 'c/t',
				hash: true,
				menu: {
					side: 'left', // 'left' or 'right'.
					width: 'normal', // 'normal', 'wide', 'third', 'half', 'full', or
					numbers: false,
					titleSelector: 'h1, h2, h3',
					useTextContentForMissingTitles: false,
					hideMissingTitles: false,
					markers: true,
					custom: false,
					themes: true,
					themesPath: 'dist/theme/',			
					transitions: false,  // ['None', 'Fade', 'Slide']
					openButton: true,
					openSlideNumber: true,
					keyboard: true,
					sticky: false,
					autoOpen: true,
					delayInit: false,
					openOnInit: false,
					loadIcons: true
						},

						math: {
					// mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
					config: 'TeX-AMS_HTML-full',
					TeX: {
						Macros: {
							R: '\\mathbb{R}',
							set: [ '\\left\\{#1 \\; ; \\; #2\\right\\}', 2 ]
								}
						}
							},

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMenu, RevealMath ],
				dependencies: [
				
								]
			});
		</script>
	</body>
</html>
